use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

use super::shared::{CveMetadata, Description, ProviderMetadata};

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Published {
    pub dataType: String,
    pub dataVersion: String,
    pub cveMetadata: CveMetadata,
    pub containers: PublishedContainer,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct PublishedContainer {
    pub cna: Cna,
    pub adp: Option<Vec<Adp>>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Cna {
    pub providerMetadata: ProviderMetadata,
    pub datePublic: Option<String>,
    pub title: Option<String>,
    pub descriptions: Vec<Description>,
    pub affected: Vec<Affected>,
    pub problemTypes: Option<Vec<ProblemTypeContainer>>,
    pub references: Vec<Reference>,
    pub impacts: Option<Vec<Impacts>>,
    pub metrics: Option<Vec<Metric>>,
    pub configurations: Option<Vec<Description>>,
    pub workarounds: Option<Vec<Description>>,
    pub solutions: Option<Vec<Description>>,
    pub exploits: Option<Vec<Description>>,
    pub timeline: Option<Vec<Timeline>>,
    pub credits: Option<Vec<Credit>>,
    // pub source: Option<Source>,
    pub tags: Option<Vec<String>>,
    pub taxonomyMappings: Option<Vec<TaxonomyMapping>>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Adp {
    pub providerMetadata: ProviderMetadata,
    pub datePublic: Option<String>,
    pub title: Option<String>,
    pub descriptions: Option<Vec<Description>>,
    pub affected: Option<Vec<Affected>>,
    pub problemTypes: Option<Vec<ProblemTypeContainer>>,
    pub references: Option<Vec<Reference>>,
    pub impacts: Option<Vec<Impacts>>,
    pub metrics: Option<Vec<Metric>>,
    pub configurations: Option<Vec<Description>>,
    pub workarounds: Option<Vec<Description>>,
    pub solutions: Option<Vec<Description>>,
    pub exploits: Option<Vec<Description>>,
    pub timeline: Option<Vec<Timeline>>,
    pub credits: Option<Vec<Credit>>,
    // pub source: Option<Source>,
    pub tags: Option<Vec<String>>,
    pub taxonomyMappings: Option<Vec<TaxonomyMapping>>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Affected {
    pub vendor: Option<String>,
    pub product: Option<String>,
    pub collectionURL: Option<String>,
    pub packageName: Option<String>,
    pub cpes: Option<Vec<String>>,
    pub modules: Option<Vec<String>>,
    pub programFiles: Option<Vec<String>>,
    pub programRoutines: Option<Vec<ProgramRoutine>>,
    pub platforms: Option<Vec<String>>,
    pub repo: Option<String>,
    pub defaultStatus: Option<String>,
    pub versions: Option<Vec<Version>>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct ProgramRoutine {
    pub name: String,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Version {
    pub version: String,
    pub status: String,
    pub versionType: Option<String>,
    pub lessThan: Option<String>,
    pub lessThanOrEqual: Option<String>,
    pub changes: Option<Vec<Changes>>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Changes {
    pub at: String,
    pub status: String,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct ProblemTypeContainer {
    pub descriptions: Vec<ProblemType>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct ProblemType {
    pub lang: String,
    pub description: String,
    pub cweId: Option<String>,
    pub r#type: Option<String>,
    pub references: Option<Vec<Reference>>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Reference {
    pub url: String,
    pub name: Option<String>,
    pub tags: Option<Vec<String>>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Impacts {
    pub capecId: Option<String>,
    pub descriptions: Vec<Description>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Metric {
    pub format: Option<String>,
    pub scenarios: Option<Vec<Scenario>>,
    pub cvssV3_1: Option<CvssV3>,
    pub cvssV3_0: Option<CvssV3>,
    pub cvssV2_0: Option<CvssV2>,
    // pub other: Option<Other>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Scenario {
    pub lang: String,
    pub value: String,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Timeline {
    pub time: String,
    pub lang: String,
    pub value: String,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct Credit {
    pub lang: String,
    pub value: String,
    pub user: Option<String>,
    pub r#type: Option<String>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct TaxonomyMapping {
    pub taxonomyName: String,
    pub taxonomyVersion: Option<String>,
    pub taxonomyRelations: Vec<TaxonomyRelations>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct TaxonomyRelations {
    pub taxonomyId: String,
    pub relationshipName: String,
    pub relationshipValue: String,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct CvssV3 {
    pub version: String,
    pub vectorString: String,
    pub attackVector: Option<String>,
    pub attackComplexity: Option<String>,
    pub privilegesRequired: Option<String>,
    pub userInteraction: Option<String>,
    pub scope: Option<String>,
    pub confidentialityImpact: Option<String>,
    pub integrityImpact: Option<String>,
    pub availabilityImpact: Option<String>,
    pub baseScore: f32,
    pub baseSeverity: String,
    pub exploitCodeMaturity: Option<String>,
    pub remediationLevel: Option<String>,
    pub reportConfidence: Option<String>,
    pub temporalScore: Option<f32>,
    pub temporalSeverity: Option<String>,
    pub confidentialityRequirement: Option<String>,
    pub integrityRequirement: Option<String>,
    pub availabilityRequirement: Option<String>,
    pub modifiedAttackVector: Option<String>,
    pub modifiedAttackComplexity: Option<String>,
    pub modifiedPrivilegesRequired: Option<String>,
    pub modifiedUserInteraction: Option<String>,
    pub modifiedScope: Option<String>,
    pub modifiedConfidentialityImpact: Option<String>,
    pub modifiedIntegrityImpact: Option<String>,
    pub modifiedAvailabilityImpact: Option<String>,
    pub environmentalScore: Option<f32>,
    pub environmentalSeverity: Option<String>,
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct CvssV2 {
    pub version: String,
    pub vectorString: String,
    pub accessVector: Option<String>,
    pub accessComplexity: Option<String>,
    pub authentication: Option<String>,
    pub confidentialityImpact: Option<String>,
    pub integrityImpact: Option<String>,
    pub availabilityImpact: Option<String>,
    pub baseScore: f32,
    pub exploitability: Option<String>,
    pub remediationLevel: Option<String>,
    pub reportConfidence: Option<String>,
    pub temporalScore: Option<f32>,
    pub collateralDamagePotential: Option<String>,
    pub targetDistribution: Option<String>,
    pub confidentialityRequirement: Option<String>,
    pub integrityRequirement: Option<String>,
    pub availabilityRequirement: Option<String>,
    pub environmentalScore: Option<f32>,
}
