use std::fs::{read_dir, File};
use std::io::{Error, ErrorKind, Read, Result};

use crate::format::{parse_json_string, CVE};
use crate::BASE_PATH;

pub fn cves_by_id(ids: Vec<String>) -> Result<Vec<CVE>> {
  let mut cves: Vec<CVE> = Vec::new();
  for id in ids {
    let cve = match cve_by_id(id) {
      Ok(cve) => cve,
      Err(e) => return Err(e),
    };
    cves.push(cve);
  }
  Ok(cves)
}

pub fn cve_by_id(id: String) -> Result<CVE> {
  let path = file_path_by_id(id);
  let cve = match cve_by_path(path) {
    Ok(cve) => cve,
    Err(e) => return Err(e),
  };
  Ok(cve)
}

pub fn cve_by_path(path: String) -> Result<CVE> {
  let mut s = String::new();
  let mut file = match File::open(path) {
    Ok(file) => file,
    Err(e) => {
      return Err(Error::new(
        ErrorKind::NotFound,
        format!("Could not read file ({})", e),
      ))
    }
  };

  file.read_to_string(&mut s)?;

  let cve: CVE = match parse_json_string(&s) {
    Ok(cve) => cve,
    Err(e) => {
      return Err(Error::new(
        ErrorKind::InvalidData,
        format!("CVE data is invalid ({})", e),
      ))
    }
  };

  Ok(cve)
}

pub fn most_recent_cve_ids(count: u32) -> Result<Vec<String>> {
  let year = most_recent_year()?;
  let mut cve_numbers: Vec<u32> = Vec::new();
  let mut nth_group = 0;

  // Collect CVEs from groups, until we have enough
  while cve_numbers.len() < count as usize {
    let group_name = match nth_most_recent_group(&year, nth_group) {
      Ok(group) => group,
      Err(_) => break,
    };
    let group_dir = read_dir(format!("{}{}/{}/", crate::BASE_PATH, year, group_name))?;

    let mut tmp_cve_numbers: Vec<u32> = group_dir
      .filter(|f| f.as_ref().unwrap().file_type().unwrap().is_file())
      .map(|p| {
        let r = p.unwrap().file_name();
        let name = r.to_str().unwrap();
        name[9..name.len() - 5].parse::<u32>().unwrap()
      })
      .collect();

    let remaining_count = count as usize - cve_numbers.len();
    let slice_length: i32 = tmp_cve_numbers.len() as i32 - remaining_count as i32;
    if slice_length > 0 {
      tmp_cve_numbers.sort();
      tmp_cve_numbers = tmp_cve_numbers[slice_length as usize..].to_vec();
    }

    cve_numbers.append(&mut tmp_cve_numbers);
    nth_group += 1;
  }

  cve_numbers.sort_by(|a, b| b.cmp(a));
  let cve_ids = cve_numbers
    .iter_mut()
    .map(|x| format!("CVE-{}-{:05}", year, x.to_string()))
    .collect::<Vec<String>>();

  Ok(cve_ids)
}

/**
* Get path to the json file, based on BASE_PATH and the CVE id .
* `CVE-YYYY-NNNNN`
*/
fn file_path_by_id(id: String) -> String {
  let year = &id[4..8]; // YYYY
  let num = &id[9..]; // NNNNN
  let group = format!("{}xxx", &num[..num.len() - 3]);

  format!(
    "{base_path}{year}/{group}/{id}.json",
    base_path = BASE_PATH,
    year = year,
    group = group,
    id = id
  )
}

fn most_recent_year() -> Result<String> {
  let base_dir = read_dir(crate::BASE_PATH)?;
  let dirs = base_dir.filter(|f| f.as_ref().unwrap().file_type().unwrap().is_dir());
  let year = dirs
    .map(|p| p.unwrap().file_name().to_str().unwrap().to_string())
    .max()
    .unwrap();
  Ok(year)
}

fn nth_most_recent_group(year: &String, nth: usize) -> Result<String> {
  let base_dir = read_dir(format!("{}/{}", crate::BASE_PATH, year))?;
  let mut dir_nums: Vec<u32> = base_dir
    .filter(|f| f.as_ref().unwrap().file_type().unwrap().is_dir())
    .map(|p| {
      let r = p.unwrap().file_name();
      let name = r.to_str().unwrap();
      name[..name.len() - 3].parse::<u32>().unwrap()
    })
    .collect();
  if nth > dir_nums.len() {
    return Err(std::io::Error::new(
      std::io::ErrorKind::NotFound,
      "Out of bounds",
    ));
  }
  dir_nums.sort();
  Ok(format!("{}xxx", dir_nums[dir_nums.len() - 1 - nth]))
}

pub fn years() -> Result<Vec<String>> {
  let base_dir = read_dir(crate::BASE_PATH)?;
  let dirs = base_dir.filter(|f| f.as_ref().unwrap().file_type().unwrap().is_dir());
  let years = dirs
    .map(|p| p.unwrap().file_name().to_str().unwrap().to_string())
    .collect();
  Ok(years)
}

pub fn groups(year: &String) -> Result<Vec<String>> {
  let base_dir = read_dir(format!("{}/{}", crate::BASE_PATH, year))?;
  let dirs = base_dir.filter(|f| f.as_ref().unwrap().file_type().unwrap().is_dir());
  let groups = dirs
    .map(|p| p.unwrap().file_name().to_str().unwrap().to_string())
    .collect();
  Ok(groups)
}

pub fn files(year: &String, group: &String) -> Result<Vec<String>> {
  let base_dir = read_dir(format!("{}/{}/{}", crate::BASE_PATH, year, group))?;
  let files = base_dir
    .filter(|f| f.as_ref().unwrap().file_type().unwrap().is_file())
    .map(|p| p.unwrap().file_name().to_str().unwrap().to_string())
    .collect();
  Ok(files)
}
