use serde_json::from_reader;
use std::fs::File;
use std::io::{BufReader, Result};

use crate::format::CVE;
use crate::utils::file_path_by_id;

pub fn cves_by_id(ids: Vec<String>) -> Result<Vec<CVE>> {
    let mut cves: Vec<CVE> = Vec::new();
    for id in ids {
        let cve = match cve_by_id(id) {
            Ok(cve) => cve,
            Err(e) => return Err(e),
        };
        cves.push(cve);
    }
    Ok(cves)
}

pub fn cve_by_id(id: String) -> Result<CVE> {
    let path = file_path_by_id(id);
    let cve = match cve_by_path(path) {
        Ok(cve) => cve,
        Err(e) => return Err(e),
    };
    Ok(cve)
}

fn cve_by_path(path: String) -> Result<CVE> {
    let file = match File::open(path) {
        Ok(file) => file,
        Err(e) => {
            return Err(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                format!("Could not read file ({})", e),
            ))
        }
    };
    let result = from_reader(BufReader::new(file));
    let cve: CVE = match result {
        Ok(cve) => cve,
        Err(e) => {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("CVE data is invalid ({})", e),
            ))
        }
    };
    if cve.cveMetadata.state != "PUBLISHED" {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "CVE is not published",
        ));
    }
    return Ok(cve);
}
