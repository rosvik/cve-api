use serde_json::from_str;
use std::fs::File;
use std::io::{Error, ErrorKind, Read, Result};

use crate::format::CVE;
use crate::utils::file_path_by_id;

pub fn cves_by_id(ids: Vec<String>) -> Result<Vec<CVE>> {
    let mut cves: Vec<CVE> = Vec::new();
    for id in ids {
        let cve = match cve_by_id(id) {
            Ok(cve) => cve,
            Err(e) => return Err(e),
        };
        cves.push(cve);
    }
    Ok(cves)
}

pub fn cve_by_id(id: String) -> Result<CVE> {
    let path = file_path_by_id(id);
    let cve = match cve_by_path(path) {
        Ok(cve) => cve,
        Err(e) => return Err(e),
    };
    Ok(cve)
}

fn cve_by_path(path: String) -> Result<CVE> {
    let mut s = String::new();
    let mut file = match File::open(path) {
        Ok(file) => file,
        Err(e) => {
            return Err(Error::new(
                ErrorKind::NotFound,
                format!("Could not read file ({})", e),
            ))
        }
    };

    file.read_to_string(&mut s)?;

    let cve: CVE = match from_str(&s) {
        Ok(cve) => cve,
        Err(e) => {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("CVE data is invalid ({})", e),
            ))
        }
    };

    if cve.cveMetadata.state != "PUBLISHED" {
        return Err(Error::new(ErrorKind::InvalidData, "CVE is not published"));
    }
    return Ok(cve);
}
