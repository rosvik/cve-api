use std::error::Error;

use libcve::format::{parse_json_string, CVE};
use postgres::{error::DbError, types::Json, Client, NoTls};

struct CveRow {
  id: String,
  title: Option<String>,
  data: serde_json::Value,
}

pub fn init() -> anyhow::Result<()> {
  let table_name: String = dotenv::var("TABLE_NAME")?;
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;

  // Check if the table exists
  let table_exists_query = format!(
    "
      SELECT EXISTS (
        SELECT FROM information_schema.tables
        WHERE table_name = '{table_name}'
      )
    "
  );
  if client.query_one(table_exists_query.as_str(), &[]).is_err() {
    return Err(anyhow::anyhow!("Table already exists"));
  }

  let create_table_query = format!(include_str!("../sql/create.sql"), table_name = table_name);
  println!("{}", create_table_query);
  client.batch_execute(&create_table_query)?;

  Ok(())
}

pub fn insert(cve: CVE) -> anyhow::Result<()> {
  let id = match &cve {
    CVE::Published(published) => published.cveMetadata.cveId.clone(),
    CVE::Rejected(rejected) => rejected.cveMetadata.cveId.clone(),
  };
  let title: Option<String> = match &cve {
    CVE::Published(published) => published.containers.cna.title.clone(),
    CVE::Rejected(_) => None,
  };

  let data: serde_json::Value = serde_json::to_value(&cve)?;
  insert_item(CveRow { id, title, data })?;
  Ok(())
}

pub fn insert_json_string(json_string: &str) -> anyhow::Result<()> {
  // Parses and validates data
  let cve = parse_json_string(json_string)?;
  insert(cve)
}

fn insert_item(cve_row: CveRow) -> anyhow::Result<()> {
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;
  let table_name: String = dotenv::var("TABLE_NAME")?;

  match client.execute(
    format!("INSERT INTO {table_name} (id, title, data) VALUES ($1, $2, $3)").as_str(),
    &[&cve_row.id, &cve_row.title, &cve_row.data],
  ) {
    Ok(_) => {}
    Err(e) => {
      if let Some(er) = e.as_db_error() {
        return Err(anyhow::anyhow!("Failed to insert item: {:?}", er.message()));
      }
      return Err(anyhow::anyhow!("Failed to insert item: {:?}", e));
    }
  };
  Ok(())
}

pub fn get(id: &str) -> anyhow::Result<CVE> {
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;
  let table_name: String = dotenv::var("TABLE_NAME")?;

  let cve_row = client.query_one(
    format!("SELECT id, title, data FROM {table_name} WHERE id = $1").as_str(),
    &[&id],
  )?;
  let data: Json<CVE> = cve_row.get(2);
  Ok(data.0)
}

pub fn search(user_query: String) -> anyhow::Result<Vec<CVE>> {
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;
  let table_name: String = dotenv::var("TABLE_NAME")?;

  let query = format!(include_str!("../sql/search.sql"), table_name = table_name,);
  let results = client.query(&query, &[&user_query])?;
  println!("{:?}", results);

  let cves: Vec<CVE> = results
    .iter()
    .map(|row| {
      let data: Json<CVE> = row.get(2);
      data.0
    })
    .collect();
  Ok(cves)
}

// TODO: Add tests once a test database is set up
// #[cfg(test)]
// mod tests {
//   use super::*;

//   fn delete(id: &str) -> anyhow::Result<()> {
//     let connection = dotenv::var("CONNECTION")?;
//     let mut client = Client::connect(connection.as_str(), NoTls)?;
//     let table_name: String = dotenv::var("TABLE_NAME")?;
//     client.execute(
//       format!("DELETE FROM {table_name} WHERE id = $1").as_str(),
//       &[&id],
//     )?;
//     Ok(())
//   }

//   #[test]
//   fn it_works() {
//     match init() {
//       Ok(_) => println!("Table created"),
//       Err(e) => println!("Init returned Err, continuing test. ({:?})", e),
//     }
//     let id = "CVE-0000-0000";
//     let json_string = include_str!("./fixtures/CVE-0000-0000.json");

//     match insert_json_string(json_string) {
//       Ok(_) => {}
//       Err(e) => println!("Insert returned Err, continuing test. ({:?})", e),
//     }

//     let cve = get(id).unwrap();
//     match cve {
//       CVE::Published(published) => assert_eq!(published.cveMetadata.cveId, id),
//       CVE::Rejected(rejected) => assert_eq!(rejected.cveMetadata.cveId, id),
//     };

//     let search_results = search("CVE-0000-0000".to_string()).unwrap();
//     println!("RESULTS: {:?}", search_results);

//     delete(id).unwrap();
//   }
// }
