use libcve::format::{parse_json_string, CVE};
use postgres::{types::Json, Client, NoTls};

struct CveRow {
  id: String,
  title: Option<String>,
  data: serde_json::Value,
}

pub fn init() -> anyhow::Result<()> {
  let table_name: String = dotenv::var("TABLE_NAME").unwrap_or("cve".to_string());
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;

  // Check if the table exists
  let table_exists_query = format!(
    "
      SELECT EXISTS (
        SELECT FROM information_schema.tables
        WHERE table_name = '{table_name}'
      )
    "
  );
  if client.query_one(table_exists_query.as_str(), &[]).is_err() {
    return Err(anyhow::anyhow!("Table already exists"));
  }

  let create_table_query = format!(
    "
      CREATE TABLE {table_name} (
          id      TEXT PRIMARY KEY,
          title   TEXT,
          data    JSONB
      )
    "
  );
  client.batch_execute(create_table_query.as_str())?;
  Ok(())
}

pub fn insert_string(json_string: &str) -> anyhow::Result<CVE> {
  // Parses and validates data
  let cve = parse_json_string(json_string)?;

  let id = match &cve {
    CVE::Published(published) => published.cveMetadata.cveId.clone(),
    CVE::Rejected(rejected) => rejected.cveMetadata.cveId.clone(),
  };
  let title: Option<String> = match &cve {
    CVE::Published(published) => published.containers.cna.title.clone(),
    CVE::Rejected(_) => None,
  };

  let data: serde_json::Value = serde_json::from_str(json_string)?;
  insert_item(CveRow { id, title, data })?;
  Ok(cve)
}

fn insert_item(cve_row: CveRow) -> anyhow::Result<()> {
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;
  let table_name: String = dotenv::var("TABLE_NAME").unwrap_or("cve".to_string());

  client.execute(
    format!("INSERT INTO {table_name} (id, title, data) VALUES ($1, $2, $3)").as_str(),
    &[&cve_row.id, &cve_row.title, &cve_row.data],
  )?;
  Ok(())
}

pub fn get(id: &str) -> anyhow::Result<CVE> {
  let connection = dotenv::var("CONNECTION")?;
  let mut client = Client::connect(connection.as_str(), NoTls)?;
  let table_name: String = dotenv::var("TABLE_NAME").unwrap_or("cve".to_string());

  let cve_row = client.query_one(
    format!("SELECT id, title, data FROM {table_name} WHERE id = $1").as_str(),
    &[&id],
  )?;
  let data: Json<CVE> = cve_row.get(2);
  Ok(data.0)
}

#[cfg(test)]
mod tests {
  use super::*;

  fn delete(id: &str) -> anyhow::Result<()> {
    let connection = dotenv::var("CONNECTION")?;
    let mut client = Client::connect(connection.as_str(), NoTls)?;
    let table_name: String = dotenv::var("TABLE_NAME").unwrap_or("cve".to_string());
    client.execute(
      format!("DELETE FROM {table_name} WHERE id = $1").as_str(),
      &[&id],
    )?;
    Ok(())
  }

  #[test]
  fn it_works() {
    match init() {
      Ok(_) => println!("Table created"),
      Err(e) => println!("Init returned Err, continuing test. ({:?})", e),
    }
    let id = "CVE-0000-0000";
    let json_string = include_str!("./fixtures/CVE-0000-0000.json");

    insert_string(json_string).unwrap();

    let cve = get(id).unwrap();
    match cve {
      CVE::Published(published) => assert_eq!(published.cveMetadata.cveId, id),
      CVE::Rejected(rejected) => assert_eq!(rejected.cveMetadata.cveId, id),
    };

    delete(id).unwrap();
  }
}
