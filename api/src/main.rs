use axum::{extract::Query, http::StatusCode, routing::get, Extension, Json, Router};
use database::Client;
use libcve::{
  file::{cve_by_id, cves_by_id, most_recent_cve_ids},
  format::CVE,
};
use serde::Deserialize;
use std::{net::SocketAddr, sync::Arc};
use tokio::sync::Mutex;

#[derive(Clone)]
pub struct AppState {
  client: Arc<Mutex<Client>>,
}
impl AppState {
  async fn new() -> Self {
    let client = database::get_connection().await.unwrap();
    AppState {
      client: Arc::new(Mutex::new(client)),
    }
  }
}

#[tokio::main]
async fn main() {
  let app_state = AppState::new().await;
  let app = Router::new()
    .route("/", get(root))
    .route("/cve", get(single_cve_handler))
    .route("/cves", get(multiple_cves_handler))
    .route("/recent", get(recent_cves_handler))
    .route("/search", get(search_handler))
    .layer(Extension(app_state));

  let addr = SocketAddr::from(([127, 0, 0, 1], 2337));
  println!("listening on http://{}", addr);
  axum::Server::bind(&addr)
    .serve(app.into_make_service())
    .await
    .unwrap();
}

async fn root() -> &'static str {
  "Hello world!\n"
}

#[derive(Deserialize)]
struct MultipleCvesParameters {
  ids: String,
}
async fn multiple_cves_handler(
  Query(query): Query<MultipleCvesParameters>,
) -> Result<Json<Vec<CVE>>, StatusCode> {
  let ids = query.ids.split(',').map(|s| s.to_string()).collect();
  let result = cves_by_id(ids);
  let cves = match result {
    Ok(cves) => cves,
    Err(e) => return Err(error_code(e)),
  };
  println!("Fetched {} CVEs", cves.len());
  Ok(Json(cves))
}

#[derive(Deserialize)]
struct SingleCveParameters {
  id: String,
}
async fn single_cve_handler(
  Query(query): Query<SingleCveParameters>,
) -> Result<Json<CVE>, StatusCode> {
  let file = cve_by_id(query.id.clone());
  let cve = match file {
    Ok(cve) => cve,
    Err(e) => return Err(error_code(e)),
  };
  println!("Fetched {}", query.id);
  Ok(Json(cve))
}

fn error_code(e: std::io::Error) -> StatusCode {
  println!("Error: {}", e);
  if e.kind() == std::io::ErrorKind::NotFound {
    return StatusCode::NOT_FOUND;
  }
  if e.kind() == std::io::ErrorKind::InvalidData {
    return StatusCode::INTERNAL_SERVER_ERROR;
  }
  StatusCode::IM_A_TEAPOT
}

#[derive(Deserialize)]
struct RecentCvesParameters {
  count: u32,
}
async fn recent_cves_handler(
  Query(query): Query<RecentCvesParameters>,
) -> Result<Json<Vec<CVE>>, StatusCode> {
  let recent_ids = most_recent_cve_ids(query.count).unwrap();
  let result = cves_by_id(recent_ids);
  let cves = match result {
    Ok(cves) => cves,
    Err(e) => return Err(error_code(e)),
  };
  println!("Fetched {} CVEs", cves.len());
  Ok(Json(cves))
}

#[derive(Deserialize)]
struct SearchParameters {
  query: String,
}
async fn search_handler(
  Query(params): Query<SearchParameters>,
  Extension(state): Extension<AppState>,
) -> Result<Json<Vec<CVE>>, StatusCode> {
  let client = state.client.lock();
  let mut client = client.await;

  let result = database::search(&mut client, params.query).await;
  match result {
    Ok(cves) => {
      println!("Fetched {} CVEs", cves.len());
      Ok(Json(cves))
    }
    Err(e) => {
      println!("Failed to search ({})", e);
      Err(StatusCode::INTERNAL_SERVER_ERROR)
    }
  }
}
